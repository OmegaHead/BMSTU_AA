\chapter{Аналитическая часть}
В данном разделе мы рассмотрим два метода умножения матриц: классический алгоритм умножения матриц и алгоритм Винограда, включая его оптимизированную версию.

\section{Матрица}

Матрица \cite{book_matrix} представляет собой таблицу чисел $a_{ik}$, которая имеет вид:
\begin{equation}
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{m2} & \ldots & a_{mn}
	\end{pmatrix},
\end{equation}
где $m$ -- количество строк, а $n$ -- количество столбцов. 
Элементы $a_{ik}$ называются элементами матрицы.

Если $A$ -- матрица, то $A_{i,j}$ обозначает элемент матрицы, который находится в $i$-й строке и $j$-м столбце.

Существуют следующие операции над матрицами:
\begin{enumerate}[label=\arabic*)]
\item сложение матриц одинакового размера;
\item вычитание матриц одинакового размера;
\item умножение матриц, если количество столбцов первой матрицы равно количеству строк второй матрицы. Результатом будет матрица с количеством строк, равным первой матрице, и столбцов, равным второй матрице.
\end{enumerate}

Заметим, что операция умножения матриц не коммутативна: если $A$ и $B$-квадратные матрицы, и $C$ -- их произведение, то $AB$ и $BA$ могут дать разные результаты $C$.

\clearpage

\section{Классический алгоритм}

Допустим, у нас есть две матрицы:

\begin{equation}
	A_{lm} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{l1} & a_{l2} & \ldots & a_{lm}
	\end{pmatrix},
	\quad
	B_{mn} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mn}
	\end{pmatrix},
\end{equation}

тогда матрица $C$
\begin{equation}
	C_{ln} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{l1} & c_{l2} & \ldots & c_{ln}
	\end{pmatrix},
\end{equation}

где
\begin{equation}
	\label{eq:M}
	c_{ij} =
	\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
\end{equation}

называется произведением матриц $A$ и $B$ \cite{book_matrix}.

Классический алгоритм реализует эту формулу \ref{eq:M}.

\section{Алгоритм Винограда}

Алгоритм Винограда \cite{book_vinograd} -- это метод умножения квадратных матриц. 
В 1987 году Дон Копперсмит и Виноград представили метод, который имеет асимптотическую сложность $O(n^{2,3755})$, и затем улучшили его в 2011 году до $O(n^{2,373})$, где $n$ - размер стороны матрицы. 
После оптимизации этот метод стал самым эффективным среди всех алгоритмов умножения матриц.

Рассмотрим пример с двумя векторами $U = (u_1, u_2, u_3, u_4)$ и $W = (w_1, w_2, w_3, w_4)$. 
Их скалярное произведение равно: $U \cdot W = u_1w_1 + u_2w_2 + u_3w_3 + u_4w_4$, что можно переписать как:

\begin{equation}
\label{equ:example_scal_mul}
U \cdot W = (u_1 + w_2)(u_2 + w_1) + (u_3 + w_4)(u_4 + w_3) - u_1u_2 - u_3u_4 - w_1w_2 - w_3w_4
\end{equation}

Теперь представим, что у нас есть матрицы $A, B, C$ определенных размеров. 
Скалярное произведение, предложенное Виноградом, можно выразить следующим образом:

\begin{equation}
\label{equ:example_scal_mul_matrix}
C_{ij} = \sum_{k=1}^{q/2}(a_{i,2k-1} + b_{2k,j})(a_{i,2k} + b_{2k-1,j}) - \sum_{k=1}^{q/2} a_{i,2k-1}a_{i,2k} - \sum_{k=1}^{q/2} b_{2k-1,j}b_{2k,j}
\end{equation}

Хотя это выражение требует больше арифметических операций, чем стандартное умножение матриц, Виноград предложил предварительно вычислять второе и третье слагаемые в уравнении \ref{equ:example_scal_mul_matrix} для каждой строки матрицы $A$ и каждого столбца матрицы $B$. 
Это позволяет значительно снизить количество вычислений в последующих шагах. 
В итоге на практике алгоритм Винограда может работать быстрее, так как операция сложения выполняется быстрее, чем умножение.

Также стоит отметить, что при нечетных размерах матрицы требуется дополнительно учитывать произведение крайних элементов соответствующих строк и столбцов.

\section{Оптимизированный алгоритм Винограда}

При реализации алгоритма Винограда можно внести следующие оптимизации:

\begin{enumerate}
\item Значение $\frac{N}{2}$, используемое как ограничение в цикле для вычисления предварительных данных, можно кэшировать;
\item Операцию умножения на 2 можно эффективно заменить побитовым\newpage сдвигом на 1;
\item Операции сложения и вычитания с присваиванием следует реализовывать с использованием соответствующих операторов $+=$ или $-=$.
\end{enumerate}

\section*{Вывод}

В данном разделе мы рассмотрели два алгоритма умножения матриц: классический и алгоритм Винограда, включая оптимизации для последнего. 
Мы также обсудили особенности умножения матриц и важность предварительных вычислений для улучшения производительности алгоритма.