\chapter{Технологическая часть}

В данной главе представлены требования к программному обеспечению, описаны средства реализации, приведены листинги кода и функциональные тесты.

\section{Требования к программному обеспечению}\label{section:requirements}

Программное обеспечение должно удовлетворять следующим функциональным требованиям: на входе - две строки, на выходе - результаты вычислений всех алгоритмов поиска расстояний, выраженные в виде целых чисел.

Программное обеспечение также должно соответствовать следующим требованиям:
\begin{itemize}[label=---]
	\item наличие пользовательского интерфейса для выбора действий;
	\item способность обрабатывать строки, содержащие символы как латинского, так и кириллического алфавитов;
	\item предоставление функционала для измерения времени выполнения алгоритмов Левенштейна и Дамерау~---~Левенштейна.
\end{itemize}

\section{Средства реализации}

Для разработки данной лабораторной работы был выбран язык программирования Swift \cite{swift}. 
Этот выбор обусловлен возможностью измерения процессорного времени \cite{cpu-time-measure}, а также возможностью хранить строки, содержащие как кириллические, так и латинские символы \cite{string}. 
Это удовлетворяет требованиям, предъявляемым к программному обеспечению.

Измерение времени выполнения алгоритмов производится с использованием функции \textit{clock\_gettime()} \cite{cpu-time-measure}.


\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры данных:

\begin{itemize}
	\item строка --- это массив символов типа $char$ длиной, равной длине строки;
	\item длина строки --- это целое число типа $int$;
	\item матрица --- это двумерный массив значений типа $int$.
\end{itemize}


\section{Сведения о модулях программы}

Программа разбита на следующие модули:

\begin{itemize}
	\item \texttt{main.swift} --- точка входа в программу, где происходит вызов алгоритмов через интерфейс;
	\item \texttt{Algorithms.swift} --- содержит реализации алгоритмов поиска расстояния Левенштейна (только итеративный) и Дамерау~---~Левенштейна (итеративный, рекурсивный и рекурсивный с кешированием);
	\item \texttt{CPUTimeMeasure.swift} --- измеряет время работы алгоритмов с учетом заданного количества повторений;
	\item \texttt{GraphRenderer.swift} --- Строит графики для каждого из алгоритмов с учетом заданного количества повторений для каждого алгоритма;
\end{itemize}

\section{Реализация алгоритмов}

В листингах \ref{lst:nonRecursiveLevenshteinDistance} -- \ref{lst:recursiveCacheDamerauLevenshteinDistance2} приведены реализации алгоритмов поиска расстояний Левенштейна (только нерекурсивный алгоритм) и Дамерау~---~Левенштейна (нерекурсивный, рекурсивный и рекурсивный с кешированием).

В листинге \ref{lst:outputMatrix} приведена реализация вывода матрицы.

\begin{lstlisting}[label=lst:nonRecursiveLevenshteinDistance,caption=Функция нахождения расстояния Левенштейна с использованием матрицы]
private static func nonRecursiveLevenshteinDistance(_ s1: String, _ s2: String, print isPrinted: Bool = false) -> Int {
	let len1 = s1.count
	let len2 = s2.count

	guard len1 > 0 else { return len2 }
	guard len2 > 0 else { return len1 }

	let s1Array = Array(s1)
	let s2Array = Array(s2)

	var matrix = Array(repeating: Array(repeating: 0, count: len2 + 1), count: len1 + 1)

	for i in 0...len1 {
		matrix[i][0] = i
	}
	for j in 0...len2 {
		matrix[0][j] = j
	}

	for i in 1...len1 {
		for j in 1...len2 {
			let cost = s1Array[i - 1] == s2Array[j - 1] ? 0 : 1
			matrix[i][j] = min(
				matrix[i - 1][j] + 1,         // Deletion
				matrix[i][j - 1] + 1,         // Insertion
				matrix[i - 1][j - 1] + cost   // Replacement
			)
		}
	}
	if isPrinted { 
		print(Constants.nonRecursiveLevenshteinMatrix)
		outputMatrix(matrix: matrix, s1: s1, s2: s2) 
	}

	return matrix[len1][len2]
}
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:nonRecursiveDamerauLevenshteinDistance,caption=Функция нахождения расстояния Дамерау~---~Левенштейна с использованием матрицы]
private static func nonRecursiveDamerauLevenshteinDistance(_ s1: String, _ s2: String, print isPrinted: Bool = false) -> Int {
	let len1 = s1.count
	let len2 = s2.count

	guard len1 > 0 else { return len2 }
	guard len2 > 0 else { return len1 }

	let s1Array = Array(s1)
	let s2Array = Array(s2)

	var matrix = Array(repeating: Array(repeating: 0, count: len2 + 1), count: len1 + 1)

	for i in 0...len1 {
		matrix[i][0] = i
	}

	for j in 0...len2 {
		matrix[0][j] = j
	}

	for i in 1...len1 {
		for j in 1...len2 {
			let cost = s1Array[i - 1] == s2Array[j - 1] ? 0 : 1

			matrix[i][j] = min(
				matrix[i - 1][j] + 1,         // Deletion
				matrix[i][j - 1] + 1,         // Insertion
				matrix[i - 1][j - 1] + cost   // Replacement
			)
			if i > 1 && j > 1 && s1Array[i - 1] == s2Array[j - 2] && s1Array[i - 2] == s2Array[j - 1] {
				matrix[i][j] = min(matrix[i][j], matrix[i - 2][j - 2] + cost)  // Transposition
			}
		}
	}
\end{lstlisting}

\begin{lstlisting}[label=lst:nonRecursiveDamerauLevenshteinDistance2,caption=Продолжение листинга \ref{lst:nonRecursiveDamerauLevenshteinDistance}]
	if isPrinted { 
		print(Constants.nonRecursiveDamerauLevenshteinMatrix)
		outputMatrix(matrix: matrix, s1: s1, s2: s2) 
	}

	return matrix[len1][len2]
}
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:recursiveDamerauLevenshteinDistance,caption=Функция нахождения расстояния Дамерау~---~Левенштейна рекурсивно]
private static func recursiveDamerauLevenshteinDistance(_ s1: [Character], _ s2: [Character], _ len1: Int, _ len2: Int) -> Int {
	guard len1 > 0 else { return len2 }
	guard len2 > 0 else { return len1 }

	let cost = s1[len1 - 1] == s2[len2 - 1] ? 0 : 1

	let deletion = recursiveDamerauLevenshteinDistance(s1, s2, len1 - 1, len2) + 1
	let insertion = recursiveDamerauLevenshteinDistance(s1, s2, len1, len2 - 1) + 1
	let replacement = recursiveDamerauLevenshteinDistance(s1, s2, len1 - 1, len2 - 1) + cost

	var transposition = Int.max

	if len1 > 1 && len2 > 1 && s1[len1 - 1] == s2[len2 - 2] && s1[len1 - 2] == s2[len2 - 1] {
		transposition = recursiveDamerauLevenshteinDistance(s1, s2, len1 - 2, len2 - 2) + cost
	}

	return min(deletion, insertion, replacement, transposition)
}
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:recursiveCacheDamerauLevenshteinDistance,caption=Функция нахождения расстояния Дамерау~---~Левенштейна рекурсивно c кешированием]
private static func recursiveCacheDamerauLevenshteinDistance(_ s1: [Character], _ s2: [Character], _ len1: Int, _ len2: Int, _ memo: inout [[Int]]) -> Int {

	guard len1 > 0 else { 
		memo[len1][len2] = len2
		return len2 
	}
	guard len2 > 0 else { 
		memo[len1][len2] = len1
		return len1
	}

	guard memo[len1][len2] == -1 else { return memo[len1][len2] }

	let cost = s1[len1 - 1] == s2[len2 - 1] ? 0 : 1

	let deletion = recursiveCacheDamerauLevenshteinDistance(s1, s2, len1 - 1, len2, &memo) + 1
	let insertion = recursiveCacheDamerauLevenshteinDistance(s1, s2, len1, len2 - 1, &memo) + 1
	let substitution = recursiveCacheDamerauLevenshteinDistance(s1, s2, len1 - 1, len2 - 1, &memo) + cost

	var transposition = Int.max

	if len1 > 1 && len2 > 1 && s1[len1 - 1] == s2[len2 - 2] && s1[len1 - 2] == s2[len2 - 1] {
		transposition = recursiveCacheDamerauLevenshteinDistance(s1, s2, len1 - 2, len2 - 2, &memo) + cost
	}

	memo[len1][len2] = min(deletion, insertion, substitution, transposition)

\end{lstlisting}

\begin{lstlisting}[label=lst:recursiveCacheDamerauLevenshteinDistance2,caption=Продолжение листинга \ref{lst:recursiveCacheDamerauLevenshteinDistance}]
	return memo[len1][len2]
}

private static func recursiveCacheDamerauLevenshteinDistance(_ s1: String, _ s2: String, print isPrinted: Bool = false) -> Int {
	let len1 = s1.count
	let len2 = s2.count
	let s1Array: [Character] = Array(s1)
	let s2Array: [Character] = Array(s2)
	var memo = Array(repeating: Array(repeating: -1, count: len2 + 1), count: len1 + 1)
	
	let distance = recursiveCacheDamerauLevenshteinDistance(s1Array, s2Array, s1.count, s2.count, &memo)
	if isPrinted { 
		print(Constants.recursiveCacheDamerauLevenshteinMatrix)
		outputMatrix(matrix: memo, s1: s1, s2: s2) }

	return distance
}
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:outputMatrix,caption=Функции вывода матрицы для алгоритмов поиска расстояния Левенштейна и Дамерау~---~Левенштейна]
private static func outputMatrix(matrix: [[Int]], s1: String, s2: String) {
	let len1 = s1.count
	let len2 = s2.count 

	let s1 = Array(s1)
	let s2 = Array(s2)

	print("   |   |", terminator: "")
	for char in s2 {
		print(" \(char) |", terminator: "")
	}
	print()

	print("---|---|", terminator: "")
	for _ in s2 {
		print("---|", terminator: "")
	}
	print()

	for i in 0...len1 {
		if i == 0 {
			print("   |", terminator: "")
		} else {
			print(" \(s1[i - 1]) |", terminator: "")
		}

		for j in 0...len2 {
			print(String(format: "%3d|", matrix[i][j]), terminator: "")
		}
		print()
	}
	print()
}
\end{lstlisting}

\clearpage

\section{Функциональные тесты}

В таблице приведены функциональные тесты для алгоритмов вычисления расстояний Левенштейна и Дамерау~---~Левенштейна. Все тесты были успешно пройдены.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
		\caption{Дополнительные функциональные тесты}
		\label{tbl:additional_func_tests}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			\multicolumn{2}{|c|}{\bfseries Входные данные}
			& \multicolumn{4}{c|}{\bfseries Расстояние и алгоритм} \\ 
			\hline 
			&
			& \multicolumn{1}{c|}{\bfseries Левенштейна} 
			& \multicolumn{3}{c|}{\bfseries Дамерау~---~Левенштейна} \\ \cline{3-6}
			
			\bfseries Строка 1 & \bfseries Строка 2 & \bfseries Итеративный & \bfseries Итеративный
			
			& \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{5-6}
			& & & & \bfseries Без кеша & \bfseries С кешом \\
			\hline
			книга & книги & 1 & 1 & 1 & 1 \\
			\hline
			кот & кошка & 3 & 3 & 3 & 3 \\
			\hline
			дом & дача & 3 & 3 & 3 & 3 \\
			\hline
			птица & рыба & 6 & 6 & 6 & 6 \\
			\hline
			привет & превет & 1 & 1 & 1 & 1 \\
			\hline
			кот & кто & 2 & 1 & 1 & 1 \\
			\hline
		\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}


\section*{Вывод}

В данной главе были представлены требования к программному обеспечению, описаны средства реализации, приведены листинги кода алгоритмов и функциональные тесты, подтверждающие корректность работы алгоритмов.
